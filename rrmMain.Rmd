---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
from tableBuilder import *
from classChildren import *
import math
from scipy.stats import norm
from scipy.stats import logistic
from scipy import special
import random
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from debug import ipsh
import warnings
warnings.filterwarnings('ignore')
```

## Create Nash Child Class


As it is, $\theta = (a_R,a_L,a_C,b,c,\mu,s,p_C,\sigma,\epsilon)$.

```{python}
class Nash(Bank):

    def I(self,a,b,c):
        return a+b*self.table['Inflation']+c*self.table['OutGap']

    def addZLZR(self,theta):
        
        aR=theta[0]; aL=theta[1]; aC=theta[2]; b=theta[3]; c=theta[4]

        i = self.table['PriorTarget'].copy()
        self.table['zL'] = i-self.I(aL,b,c)
        self.table['zR'] = i-self.I(aR,b,c)
        
    def addILIR(self,theta,zeta='zeta'):
        
        aR=theta[0]; aL=theta[1]; aC=theta[2]; b=theta[3]; c=theta[4]
        
        self.table['IL_'+zeta] = self.I(aL,b,c)+self.table[zeta]
        self.table['IR_'+zeta] = self.I(aR,b,c)+self.table[zeta]
        
    def G(self,theta,stepApprox=norm.cdf,zeta='zeta',target='Target'):
        
        aR=theta[0]; aL=theta[1]; aC=theta[2]; b=theta[3]; c=theta[4];
        mu=theta[5]; s=theta[6]; pC=theta[7]; sigma=theta[8]; eps=theta[9]
        
        self.table['G'] = stepApprox((self.I(aC,b,c)-self.table[target]+self.table[zeta])/eps)
        
        return self.table['G']
    
    def g(self,theta,zeta='zeta',target='Target',stepApproxPDF=norm.pdf):

        aR=theta[0]; aL=theta[1]; aC=theta[2]; b=theta[3]; c=theta[4];
        mu=theta[5]; s=theta[6]; pC=theta[7]; sigma=theta[8]; eps=theta[9]
        
        self.table['g'] = stepApproxPDF((self.I(aC,b,c)-self.table['Target']+self.table[zeta])/eps)
        
        return self.table['g']
    
    ######################################
    #                                    #
    #      Solving for rho and zeta      #
    #                                    #
    ######################################

    def guessRho(self,theta,zeta='zeta',target='target'):
        
        aR=theta[0]; aL=theta[1]; aC=theta[2]; b=theta[3]; c=theta[4];
        mu=theta[5]; s=theta[6]; pC=theta[7]; sigma=theta[8]; eps=theta[9]
        
        self.addZLZR(theta)
        rho = pd.Series([1-self.F(mu)]*self.table['Date'].size)
        self.table['rho_'+zeta] = rho.copy()

        return rho
    
    def giveZ(self,theta,plot=False,zeta='zeta',target='Target',rho='rho_zeta',chairman=False):
        
        aR=theta[0]; aL=theta[1]; aC=theta[2]; b=theta[3]; c=theta[4];
        mu=theta[5]; s=theta[6]; pC=theta[7]; sigma=theta[8]; eps=theta[9]
        
        self.table['ChangeSign'] = (self.table[target]-self.table['PriorTarget']).apply(np.sign)
        comm = 1/2*(self.table[target]-self.table['PriorTarget'])
        i = self.table[target].copy()
      
        B = 2*((self.I(aL,b,c)+self.I(aR,b,c))/2-i+1/2*comm)
        C = (self.I(aL,b,c)-i)*(self.I(aR,b,c)-i)+comm*(self.table[rho]*\
                    self.I(aL,b,c)+(1-self.table[rho])*self.I(aR,b,c)-i)

        if plot:
            self.addZLZR(theta)
            x = np.arange(-2,5,.1)
            y = x**2+B[1]*x+C[1]
            zero = np.zeros(x.size)
            fig, ax = plt.subplots()
            ax.plot(x,y)
            ax.plot(x,zero)
            ax.axvline(self.table['zL'][1],color='r')
            ax.axvline(self.table['zR'][1],color='m')
            plt.show()
        
        self.table[zeta] = pd.Series([0]*self.T)
        self.table[zeta][self.table['ChangeSign']==1] = (-B+(B**2-4*C)**(1/2))/2
        self.table[zeta][self.table['ChangeSign']==-1] = (-B-(B**2-4*C)**(1/2))/2
        return self.table[zeta]

        
    def giveRho(self,theta,zeta='zeta',target='Target',new=False,F=logistic.cdf):
        
        aR=theta[0]; aL=theta[1]; aC=theta[2]; b=theta[3]; c=theta[4];
        mu=theta[5]; s=theta[6]; pC=theta[7]; sigma=theta[8]; eps=theta[9]
        
        i = self.table[target].copy()
        
        if new:
            rho = pC*self.G(theta,zeta=zeta)+(1-pC)*((self.I(mu,b,c)+self.table['new_'+zeta]-i)/s).apply(F)
            rho[rho>1]=1; rho[rho<0]=0
            self.table['newRho_'+zeta] = rho.copy()
            
        else:
            rho = pC*self.G(theta,zeta=zeta)+(1-pC)*((self.I(mu,b,c)+self.table[zeta]-i)/s).apply(F)
            rho[rho>1]=1; rho[rho<0]=0
            self.table['rho_'+zeta] = rho.copy()   
        
        return rho
    
    
    def getRhoZHelper(self,theta,zeta='zeta',target='Target',conv=0.0001,printN=False,n=0):
        
        aR=theta[0]; aL=theta[1]; aC=theta[2]; b=theta[3]; c=theta[4];
        mu=theta[5]; s=theta[6]; pC=theta[7]; sigma=theta[8]; eps=theta[9]
        
        n+=1
        
        newZeta = 'new_'+zeta
        self.giveZ(theta,zeta=newZeta,target=target,rho='rho_'+zeta)
        self.giveRho(theta,zeta=zeta,target=target,new=True)
        
        if n==100:
            print('fooooooooork')
            ipsh()
        
        if target!='Target':
            rhoConv = all((self.table['rho_'+zeta]-self.table['newRho_'+zeta])\
                      [(self.table['Chairman_'+zeta]==0)].apply(abs)<conv)
            zConv = all((self.table[zeta]-self.table[newZeta])\
                    [(self.table['Chairman_'+zeta]==0)].apply(abs)<conv)
            
        else:                             
            rhoConv = all((self.table['rho_'+zeta]-self.table['newRho_'+zeta])\
                          [(self.table['ChangeSign']!=0)&(self.table['Chairman_'+zeta]==0)].apply(abs)<conv)
            zConv = all((self.table[zeta]-self.table[newZeta])\
                        [(self.table['ChangeSign']!=0)&(self.table['Chairman_'+zeta]==0)].apply(abs)<conv)
            
        if n==100:
            ipsh()
            
        self.table[zeta] = self.table[newZeta].copy(); self.table = self.table.drop([newZeta],axis=1)
        self.table['rho_'+zeta] = self.table['newRho_'+zeta].copy(); self.table = self.table.drop(['newRho_'+zeta],axis=1) 
        
        try:
            self.table[zeta][self.table['Chairman_'+zeta]==1]=\
            -(aC+b*self.table['Inflation']+c*self.table['OutGap']-self.table[target])
        except:
            pass
       
        if (rhoConv,zConv) == (True,True):
            if printN:
                print(n)
            return self.table
            
        return self.getRhoZHelper(theta,zeta,target,conv,printN,n)
    
    ######################################
    #                                    #
    #      Code for Gradient Ascent      #
    #                                    #
    ######################################
    
    def chairmanHelper(self,theta,zeta='zeta'):
        
        aR=theta[0]; aL=theta[1]; aC=theta[2]; b=theta[3]; c=theta[4];
        mu=theta[5]; s=theta[6]; pC=theta[7]; sigma=theta[8]; eps=theta[9]
        
        self.table['Chairman_'+zeta] = pd.Series([0]*self.T)
        self.table['lower'] = pd.Series([(1-pC)*self.F((mu-aC)/s)]*self.T)
        self.table['upper'] = pd.Series([pC+(1-pC)*self.F((mu-aC)/s)]*self.T)
        self.giveZ(theta,zeta='lowerZ',rho='lower')
        self.giveZ(theta,zeta='upperZ',rho='upper')
        self.table['atLower'] = (self.table['Target']-b*self.table['Inflation']-c*self.table['OutGap']-self.table['lowerZ']).copy()       
        self.table['atUpper'] = (self.table['Target']-b*self.table['Inflation']-c*self.table['OutGap']-self.table['upperZ']).copy()
        self.dropCols(['lower','upper','lowerZ','upperZ'])
        
        try:
            self.table['Chairman_'+zeta][(aC<self.table['atUpper']) & (aC>self.table['atLower'])]=1
        except:
            pass
    
    def makeGrid(self,theta,binSize=2,pC_binSize=0.4,numDraws=40):

        aR=theta[0]; aL=theta[1]; aC=theta[2]; b=theta[3]; c=theta[4];
        mu=theta[5]; s=theta[6]; pC=theta[7]; sigma=theta[8]; eps=theta[9]
        
        params = np.array([aR,aL,aC,b,c,mu,s,pC,sigma])
        grids = []
        for i in range(len(theta)-1):
            grids.append([])
            for j in range(numDraws):
                if i==6 or i==8:
                    grids[i].append(random.uniform(max(params[i]-binSize,0),params[i]+binSize))
                elif i==7:
                    grids[i].append(random.uniform(max(params[i]-pC_binSize,0),min(params[i]+pC_binSize,1)))
                else:
                    grids[i].append(random.uniform(params[i]-binSize,params[i]+binSize))
            
        self.grid = pd.DataFrame(np.transpose(np.array(grids)))
        self.grid.columns = ['aR','aL','aC','b','c','mu','s','pC','sigma']
        return(self.grid)
    
    def computeGridLL(self,theta,**grid_kwargs):

        self.makeGrid(theta,**grid_kwargs)
        params = {0:'aR',1:'aL',2:'aC',3:'b',4:'c',5:'mu',6:'s',7:'pC',8:'sigma'}
        
        def makeThetaLL(row):
            rowTheta = row.values
            rowTheta = np.append(rowTheta,theta[-1])
            try:
                return self.lln(rowTheta)
            except:
                return None
                
        self.grid['LL'] = self.grid.apply(lambda row: makeThetaLL(row), axis=1)
        return(self.grid)
    
    def checkParams(self,theta):
        
        if theta[6]<0:
            theta[6]=0
        
        if theta[7]>1:
            theta[7]=1
            
        elif theta[7]<0:
            theta[7]=0
            
        if theta[8]<0:
            theta[8]=0
            
        return theta
            
    def searchWeights(self,n):
        
        if n<=20:
            return 1
        elif n<=30:
            return 0.5
        elif n<=40:
            return 0.25
        elif n<=60:
            return 0.125
        elif n<=80:
            return 0
    
    def gradAscentNash(self,alpha,estimate,conv = 0.0001,ll=False,est=False,n=1,m=0,v=0,beta_1=0.9,beta_2=0.999,**grid_kwargs):
        
        anotherEpsilon = 10e-8
        estimate=self.checkParams(estimate)
        
        #numDraws=10,binSize=2*random.uniform(.25,1),pC_binSize=0.4*random.uniform(0.25,1)

        if n%10==1 and n<70:
            self.computeGridLL(estimate,**grid_kwargs)
            row = self.grid['LL'].argmax()
            newEstimate = self.grid.loc[row].copy().values
            newEstimate[-1] = estimate[-1]
            if self.grid['LL'].max()>self.lln(estimate):
                estimate = newEstimate
        
        if est:
            print(estimate)
        
        # adapted from https://towardsdatascience.com/adam-latest-trends-in-deep-learning-optimization-6be9a291375c
        gradient = self.gradNash(estimate)
        m = beta_1 * m + (1 - beta_1) * gradient
        m_tild = beta_1*m + (1-beta_1)*gradient
        v = beta_2 * v + (1 - beta_2) * np.power(gradient, 2)
        m_hat = m_tild / (1 - np.power(beta_1, n))
        v_hat = v / (1 - np.power(beta_2, n))
        w = alpha*m_hat / (np.sqrt(v_hat) + anotherEpsilon)

        update = estimate[0:-1]+w
        update = np.append(update,estimate[-1])
        
        update = self.checkParams(update)
        
        theta=self.checkParams(estimate)

        priorLL = self.lln(estimate)
        newLL = self.lln(update)

        improve = newLL>priorLL

        n+=1

        if ll:
            print(newLL)

        if improve:    
            if abs(newLL-priorLL)<=conv:
                return update

        return(self.gradAscentNash(alpha,update,conv,ll,est,n,m,v))

        #return self.gradAscentNash(worseWeight*alpha,estimate,conv,ll,est,worseWeight,betterWeight,n,m,v)
            
    
    def compareGradToLLN(self,theta,epsilon=0.00001,delta=0.001,start=0,end=9):
        
        params = {0:'aR',1:'aL',2:'aC',3:'b',4:'c',5:'mu',6:'s',7:'pC',8:'sigma'}
        
        good = True
        grad = self.gradNash(theta)
        
        for i in range(start,end):
            beta = theta[:]
            beta[i] = beta[i]+epsilon
            
            if abs(self.gradNash(theta)[i]-(self.lln(beta)-self.lln(theta))/epsilon)>=delta:
                print(params[i])
                print(grad[i])
                print(((self.lln(beta)-self.lln(theta))/epsilon))
                good = False
                
        print('Done!')       
        if good:
            print("You're all good!")
            
    def checkGradImprovingNash(self,theta,epsilon=0.00001,start=0,end=9):
        
        good = True
        llh = self.lln(theta)
        
        for i in range(start,end):
            blarp = theta[:]
            blarp[i] = blarp[i]+epsilon*self.gradNash(theta)[i]
            if (self.lln(blarp)<llh):
                good = False
                print(i)
        
        print('Done!')       
        if good:
            print("You're all good!")
            
#Fed = Nash('Fed2',trunc=(7,None),dropCols=['Change','Tau'])
```

```{python}
class Continuous(Nash):
    
    def getRhoZ(self,theta,**helper_kwargs):
        
        aR=theta[0]; aL=theta[1]; aC=theta[2]; b=theta[3]; c=theta[4];
        mu=theta[5]; s=theta[6]; pC=theta[7]; sigma=theta[8]; eps=theta[9]
                      
        self.guessRho(theta)
        self.giveZ(theta)
        self.giveRho(theta)
        self.chairmanHelper(theta)
        self.getRhoZHelper(theta,**helper_kwargs) 
        self.addZLZR(theta)
        self.addILIR(theta)
        
        try:
            self.table['zeta'][self.table['ChangeSign']==0]=None; self.table['rho_zeta'][self.table['ChangeSign']==0]=None
            self.table['rho_zeta'][self.table['Chairman_zeta']==1]=None
        except:
            pass
            
        self.dropCols(['atLower','atUpper'])
        
        return self.table
    
    def lln(self,theta):
        
        aR=theta[0]; aL=theta[1]; aC=theta[2]; b=theta[3]; c=theta[4];
        mu=theta[5]; s=theta[6]; pC=theta[7]; sigma=theta[8]; eps=theta[9]
        
        self.getRhoZ(theta)

        sumOne = -1/(2*sigma**2)*(self.table['zeta'].where(self.table['ChangeSign']!=0)**2).sum()
        sumTwo =  ((self.table['zR']/sigma).where(self.table['ChangeSign']==0).apply(norm.cdf)\
                -(self.table['zL']/sigma).where(self.table['ChangeSign']==0).apply(norm.cdf)).apply(math.log).sum()

        return(-self.T*(1/2*math.log(2*math.pi)+math.log(sigma))+sumOne+sumTwo)


    def gradNashFirst(self,theta): 
        
        aR=theta[0]; aL=theta[1]; aC=theta[2]; b=theta[3]; c=theta[4];
        mu=theta[5]; s=theta[6]; pC=theta[7]; sigma=theta[8]; eps=theta[9]
        
        i = self.table['Target'].copy(); z = self.table['zeta'].copy(); rho = self.table['rho_zeta'].copy()

        comm = 1/2*(self.table['Target']-self.table['PriorTarget'])
        den = 2*(z+(self.I(aL,b,c,)+self.I(aR,b,c))/2-i)+\
                comm+comm*(aL-aR)*(pC/eps*self.g(theta)+(1-pC)/s*self.f((self.I(mu,b,c)+z-i)/s))

        dZdaR = -(z+(self.I(aL,b,c)-i)+comm*(1-rho))/den
        dZdaL = -(z+(self.I(aR,b,c)-i)+comm*rho)/den
        dZdaC = -pC/eps*self.g(theta)*comm*(aL-aR)*(-1)
        dZdMu = -(1-pC)/s*comm*(aL-aR)*self.f((self.I(mu,b,c)+z-i)/s)/den
        dZdS = (comm*(1-pC)*(aL-aR)*((self.I(mu,b,c)+z-i)/s**2)*\
                self.f((self.I(mu,b,c)+z-i)/s))/den
        dZdpC = -comm*(aL-aR)*(self.G(theta)-self.F((self.I(mu,b,c)+z-i)/s))/den

        gradaR = -(z*dZdaR)/sigma**2
        gradaL = -(z*dZdaL)/sigma**2
        gradaC = -(z*dZdaC)/sigma**2
        gradB = (z*self.table['Inflation'])/sigma**2
        gradC = (z*self.table['OutGap'])/sigma**2
        gradMu = -(z*dZdMu)/sigma**2
        gradS = -(z*dZdS)/sigma**2
        gradpC = -(z*dZdpC)/sigma**2
        gradSigma = (z**2)/sigma**3

        return(gradaR,gradaL,gradaC,gradB,gradC,gradMu,gradS,gradpC,gradSigma)

    def gradNashSecond(self,theta):
        
        aR=theta[0]; aL=theta[1]; aC=theta[2]; b=theta[3]; c=theta[4];
        mu=theta[5]; s=theta[6]; pC=theta[7]; sigma=theta[8]; eps=theta[9]
        
        numr = (self.table['zR']/sigma).apply(norm.pdf)-(self.table['zL']/sigma).apply(norm.pdf)
        den = (self.table['zR']/sigma).apply(norm.cdf)-(self.table['zL']/sigma).apply(norm.cdf)
        
        gradaR = -1/sigma*((self.table['zR']/sigma).apply(norm.pdf)/den)
        gradaL = 1/sigma*((self.table['zL']/sigma).apply(norm.pdf)/den)
        gradaC = pd.Series([0]*self.T)
        gradB = -1/sigma*(self.table['Inflation']*numr/den)
        gradC = -1/sigma*(self.table['OutGap']*numr/den)
        gradMu = pd.Series([0]*self.T)
        gradS = pd.Series([0]*self.T)
        gradpC = pd.Series([0]*self.T)
        gradSigma = -1/(sigma**2)*(self.table['zR']*(self.table['zR']/sigma).apply(norm.pdf)-\
                                 self.table['zL']*(self.table['zL']/sigma).apply(norm.pdf))/den

        return(gradaR,gradaL,gradaC,gradB,gradC,gradMu,gradS,gradpC,gradSigma)
    
    def gradNashThird(self,theta):
        
        i = self.table['Target'].copy(); z = self.table['zeta'].copy(); rho = self.table['rho_zeta'].copy()
        
        aR=theta[0]; aL=theta[1]; aC=theta[2]; b=theta[3]; c=theta[4];
        mu=theta[5]; s=theta[6]; pC=theta[7]; sigma=theta[8]; eps=theta[9]
        
        gradaR = pd.Series([0]*self.T)
        gradaL = pd.Series([0]*self.T)
        gradaC = z/sigma**2
        gradB = (z*self.table['Inflation'])/sigma**2
        gradC = (z*self.table['OutGap'])/sigma**2
        gradMu = pd.Series([0]*self.T)
        gradS = pd.Series([0]*self.T)
        gradpC = pd.Series([0]*self.T)
        gradSigma = (z**2)/sigma**3
        
        return(gradaR,gradaL,gradaC,gradB,gradC,gradMu,gradS,gradpC,gradSigma)

    def gradNash(self,theta,**getRhoZ_kwargs):
        
        sigma = theta[-2]
        self.getRhoZ(theta,**getRhoZ_kwargs)
        
        gradaR=0.0; gradaL=0.0; gradaC=0.0; gradB=0.0; gradC=0.0; gradMu=0.0; gradS=0.0; gradpC=0.0; gradSigma=0.0
        grads = np.array([gradaR, gradaL, gradaC, gradB, gradC, gradMu, gradS, gradpC, gradSigma])
        for i in range(len(theta)-1):
            
            grads[i] = self.gradNashFirst(theta)[i].where(self.table['ChangeSign']!=0).where(self.table['Chairman_zeta']==0).sum()+\
                     self.gradNashSecond(theta)[i].where(self.table['ChangeSign']==0).sum()+\
                     self.gradNashThird(theta)[i].where(self.table['ChangeSign']!=0).where(self.table['Chairman_zeta']==1).sum()
        
        grads[8]=grads[8]-self.T/sigma
        
        return(grads)

BoC = Continuous('BoC',cpiType='TotalCPI',lam=129600,trunc=(12,None),dropCols=['TotalCPI','TotalCPI_SA','Change','Tau'])
```

```{python}
class Discrete(Nash):
    
    def getRhoZ(self,theta,**helper_kwargs):
        
        aR=theta[0]; aL=theta[1]; aC=theta[2]; b=theta[3]; c=theta[4];
        mu=theta[5]; s=theta[6]; pC=theta[7]; sigma=theta[8]; eps=theta[9]
        
        self.table['T_high'] = self.table['Target']+0.125
        self.table['T_low'] = self.table['Target']-0.125
        self.table['ChangeSign']
        
        self.guessRho(theta,zeta='zetaHigh')
        self.giveZ(theta,zeta='zetaHigh',target='T_high',rho='rho_zetaHigh')
        self.giveRho(theta,zeta='zetaHigh',target='T_high')
        
        self.guessRho(theta,zeta='zetaLow')
        self.giveZ(theta,zeta='zetaLow',target='T_low',rho='rho_zetaLow')
        self.giveRho(theta,zeta='zetaLow',target='T_low')
        
        self.chairmanHelper(theta,zeta='zetaHigh')
        self.chairmanHelper(theta,zeta='zetaLow')
        
        self.getRhoZHelper(theta,zeta='zetaHigh',target='T_high',**helper_kwargs) 
        self.getRhoZHelper(theta,zeta='zetaLow',target='T_low',**helper_kwargs) 

        self.addZLZR(theta)
        self.addILIR(theta,zeta='zetaHigh')
        self.addILIR(theta,zeta='zetaLow')
        
        try:
            self.table['rho_zetaHigh'][self.table['Chairman_zetaHigh']==1]=None
            self.table['rho_zetaLow'][self.table['Chairman_zetaLow']==1]=None

        except:
            pass
            
        self.dropCols(['atLower','atUpper'])
        
    def lln(self,theta):
        
        aR=theta[0]; aL=theta[1]; aC=theta[2]; b=theta[3]; c=theta[4];
        mu=theta[5]; s=theta[6]; pC=theta[7]; sigma=theta[8]; eps=theta[9]
    
        self.getRhoZ(theta)
        
        llh =  ((self.table['zetaHigh']/sigma).apply(norm.cdf)\
                -(self.table['zetaLow']/sigma).apply(norm.cdf)).apply(math.log).sum()

        return(llh)


    def dZ(self,theta,target,zeta): 
        
        aR=theta[0]; aL=theta[1]; aC=theta[2]; b=theta[3]; c=theta[4];
        mu=theta[5]; s=theta[6]; pC=theta[7]; sigma=theta[8]; eps=theta[9]
        
        i = self.table[target].copy(); z = self.table[zeta].copy(); rho = self.table['rho_'+zeta].copy()

        comm = 1/2*(self.table[target]-self.table['PriorTarget'])
        den = 2*(z+(self.I(aL,b,c,)+self.I(aR,b,c))/2-i)+\
                comm+comm*(aL-aR)*(pC/eps*self.g(theta,zeta=zeta)+(1-pC)/s*self.f((self.I(mu,b,c)+z-i)/s))

        dZdaR = -(z+(self.I(aL,b,c)-i)+comm*(1-rho))/den
        dZdaL = -(z+(self.I(aR,b,c)-i)+comm*rho)/den
        dZdaC = -pC/eps*self.g(theta,zeta=zeta)*comm*(aL-aR)*(-1)
        dZdB = -self.table['Inflation']
        dZdC = -self.table['OutGap']
        dZdMu = -(1-pC)/s*comm*(aL-aR)*self.f((self.I(mu,b,c)+z-i)/s)/den
        dZdS = (comm*(1-pC)*(aL-aR)*((self.I(mu,b,c)+z-i)/s**2)*\
                self.f((self.I(mu,b,c)+z-i)/s))/den
        dZdpC = -comm*(aL-aR)*(self.G(theta,zeta=zeta)-self.F((self.I(mu,b,c)+z-i)/s))/den
        
        dZdaR[self.table['Chairman_'+zeta]==1]=0
        dZdaL[self.table['Chairman_'+zeta]==1]=0
        dZdaC[self.table['Chairman_'+zeta]==1]=-1
        dZdMu[self.table['Chairman_'+zeta]==1]=0
        dZdS[self.table['Chairman_'+zeta]==1]=0
        dZdpC[self.table['Chairman_'+zeta]==1]=0
        
        return(dZdaR,dZdaL,dZdaC,dZdB,dZdC,dZdMu,dZdS,dZdpC)

    def gradNash(self,theta):
        
        sigma = theta[-2]
        self.getRhoZ(theta)
        
        gradaR=0.0; gradaL=0.0; gradaC=0.0; gradB=0.0; gradC=0.0; gradMu=0.0; gradS=0.0; gradpC=0.0; gradSigma=0.0
        dZ_high = np.array(self.dZ(theta,'T_high','zetaHigh'))
        dZ_low = np.array(self.dZ(theta,'T_low','zetaLow'))
        grads = np.array([gradaR, gradaL, gradaC, gradB, gradC, gradMu, gradS, gradpC, gradSigma])
        for i in range(len(grads)-1): 
            grads[i] = 1/sigma * (((self.table['zetaHigh']/sigma).apply(norm.pdf)*dZ_high[i]-(self.table['zetaLow']/sigma).apply(norm.pdf)*dZ_low[i])/\
            ((self.table['zetaHigh']/sigma).apply(norm.cdf)-(self.table['zetaLow']/sigma).apply(norm.cdf))).sum()

        grads[-1]= -1/sigma**2 * (((self.table['zetaHigh']/sigma).apply(norm.pdf)*self.table['zetaHigh']\
                                -(self.table['zetaLow']/sigma).apply(norm.pdf)*self.table['zetaLow'])/\
                                ((self.table['zetaHigh']/sigma).apply(norm.cdf)-(self.table['zetaLow']/sigma).apply(norm.cdf))).sum()
        
        return(grads)
    
    
BoC = Discrete('BoC',cpiType='TotalCPI',lam=129600,trunc=(12,None),dropCols=['TotalCPI','TotalCPI_SA','Change','Tau'])
```

```{python}
BoC.table['ChangeSign'][BoC.table['ChangeSign']==0].size
```

```{python}
BoC.compareGradToLLN(theta,epsilon=0.000000001)
```

```{python}
BoC.compareGradToLLN(theta,epsilon=0.000000001,start=8,end=9)
```

```{python}
#BoC
#theta = [2.87094784, 4.506676, 4.4, -0.17693375, -0.95165285, 5, 1.36465979, 0.2, 0.80543946,0.1]

#Fed
### theta = [1.02956614,3.79123651, 2.12936925, 0.67814839, -2.68600361,1.31300212, 2.59155696, 1., 1.02428965, 0.1 ]

theta = [0.1 , 5 , 1.2 , 0 ,-0.4 , 1 ,3 , 0.6 , 0.8 , 0.2]
#theta = [1.66836163,  3.71916583,  1.95626927,  0.19763735, -1.05312647,  2.01352984,3.1512265,   0.65155844,  1.20431678,  0.2  ]
#theta = [1.66836163,  3.71916583,  3.719,  0.19763735, -1.05312647,  2.01352984,3.1512265,   0.65155844,  1.20431678,  0.2  ]
### theta = [0.97870149, 3.74690127, 2.40183283, 0.69090601, -2.71082351, -0.47811126, 3.50354155, 1., 1.02244263, 0.2]
```

## Grad Ascent MLE

```{python}
BoC.gradAscentNash(0.01,theta,ll=True,est=True,conv=0.0001,numDraws=10,binSize=2*random.uniform(.25,1),pC_binSize=0.4*random.uniform(0.25,1)) # total_SA
```

```{python}
finalFed = [0.96405556,  3.72723961,  2.35336394,  0.6964615 , -2.69918336,
       -0.08721112,  2.84102282,  1.00989592,  1.02183077,  0.2]
finalBoC = [1.74815774,  3.26906496,  2.45751539,  0.33224235, -0.82289919,
        1.75681306,  2.11248513,  1.        ,  0.78725741,  0.2]
finalBoCDis = [1.69405223,  3.29148364,  3.55331481,  0.33436809, -0.86039531,
       -0.34094576,  9.25546417,  0.        ,  1.01629423,  0.2 ]
```

```{python}
BoC.gradNash(finalBoCDis)
```

```{python}
BoC.compareGradToLLN(finalBoCDis)
```

## Z-plots

```{python}
plt.hist(Fed.table['nashZ'], bins=8)
```

```{python}
plt.hist(BoC.table['nashZ'], bins=8)
```

## Results


| Bank | $a_R$ | $a_L$ | $a_C$ | $b$ | $c$ | $\mu$ | $s$ | $p_C$ | $\sigma$ | $eps$ |
|---|---|---|---|---|---|---|---|---|---|---|
| Bank of Canada Total SA|1.63409959|3.16218375|2.37604565|0.37368738|-0.81679396|1.13783871|3.74532325|1.0|0.78785134|0.2|
| Bank of Canada Total |1.74815774|3.26906496|2.45751539|0.33224235|-0.82289919|1.75681306|2.11248513|1.0|0.78725741|0.2|
| Bank of Canada Core CPI |1.80539449|3.84184997|2.7800699|0.19361319|-0.89938782|1.9975356|2.37650492|1.0|1.04782968|0.2|
| Fed |0.96405556|3.72723961|2.35336394|0.6964615|-2.69918336|-0.08721112|2.84102282|1.0|1.02183077|0.2|
|BoC Discrete Total |1.69405223|3.29148364|3.55331481|0.33436809| -0.86039531| -0.34094576|9.25546417|0.|1.01629423|0.2 



## Jake Learning Pandas

```{python}
charlesDarwin = pd.Series([1,1,3,9])
charlesBarkley = pd.Series([6,6,6,6])
charlesLindbergh = pd.Series([8,7,5,4])

timetomakeadataframe = pd.DataFrame(np.transpose(np.array([charlesDarwin,charlesBarkley,charlesLindbergh])))
timetomakeadataframe.columns = ['chuckyD','chuckyB','chuckyL']

timetomakeadataframe['chuckyB'][(timetomakeadataframe['chuckyD']<4)&(timetomakeadataframe['chuckyL']>6)]=0
#timetomakeadataframe.where(timetomakeadataframe['chuckyL']==0).sum()
timetomakeadataframe
```

```{python}
nationOfCheescakes = timetomakeadataframe[timetomakeadataframe['chuckyD']<4].copy()
nationOfCheescakes['chuckyB'][nationOfCheescakes['chuckyL']>6]=0
nationOfCheescakes[['chuckyB','chuckyL']]
```

```{python}
kingMidas = timetomakeadataframe['chuckyD']
kingMidas[0]=79
timetomakeadataframe

kingTut = timetomakeadataframe['chuckyD'] + 1
kingTut[1] = -10
timetomakeadataframe
```

## Misc

```{python}
BoCNash.getRhoZ(theta)

aR=2.87; aL=4.51; aC=3.5; b=-0.17693375; c=-0.95165285; mu=5

index=1

def nash(i):
    return  (-(aL+b*BoCNash.table['Inflation'][index]+c*BoCNash.table['OutGap'][index]-(i-\
            BoCNash.table['PriorTarget'][index])/2+BoCNash.table['nashZ'][index])*(i-\
            BoCNash.table['PriorTarget'][index]))**BoCNash.table['rho'][index]*\
            (-(aR+b*BoCNash.table['Inflation'][index]+c*BoCNash.table['OutGap'][index]-(i-\
            BoCNash.table['PriorTarget'][index])/2+BoCNash.table['nashZ'][index])*(i-\
            BoCNash.table['PriorTarget'][index]))**(1-BoCNash.table['rho'][index])

possibleI = pd.Series(np.linspace(.1,8,1000))

## just to parse this bit for you, possibleI.apply(nash) will output the vector nash(possibleI)
## argmax returns the index of the vector where the value is greatest
possibleI[possibleI.apply(nash).argmax()]
```
